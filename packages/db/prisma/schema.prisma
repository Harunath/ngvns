generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AdminRole {
  ROOT
  SUPER
  COMMAND
  FINANCE
  DATA_ENTRY
}

model Admin {
  id            String   @id @default(uuid())
  email         String   @unique
  emailVerified Boolean  @default(false)
  password      String
  fullname      String
  phone         String  @unique
  role          AdminRole
  active        Boolean  @default(true)
  // TOTP (MVP 2FA)
  totpSecret    String?  // base32; null until enrolled
  totpEnabled   Boolean  @default(false)

  // Relations you already have:
  ApprovedUserPayouts  UserPayout[] @relation("PayoutApprovedBy")
  RequestedUserPayouts UserPayout[] @relation("PayoutRequestedBy")
  createdPayoutBatches PayoutBatch[]
  approvedPayoutBatches PayoutBatch[] @relation("PayoutBatchApprovedBy")

  allocationsMade LandAllocation[]
  issuedBenefit  Benefit[]

  auditLogs     AdminAuditLog[] @relation("ActorAdminAuditLogs")
  PayoutAttachments PayoutAttachment[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}


model User {
  id               String         @id @default(uuid())
  fullname         String
  relationType     RelationType
  relationName     String
  dob              DateTime
  address          Address?       @relation("UserAddress")
  phone            String         @unique
  email            String         @unique
  emailVerified    Boolean
  aadhaar          String
  aadhaarVerified  Boolean
  password         String
  gender           GenderType     @default(None)
  userPhoto        String
  vrKpId           String         @unique
  nominieeName     String
  nominieeDob      DateTime
  relationship     String
  deleted          Boolean        @default(false)
  deactivated      Boolean        @default(false)
  onBoardingId     String         @unique
  orderId          String         @unique


  healthCard       Boolean        @default(false)
  healthCareDocument String?
  VRKP_Card        VRKP_Card?

  landAllotments   LandAllocation[]
  benefits        Benefit[]
  
  parentBId        String?
  parentCId        String?
  parentReferralId String?



  bankDetails      BankDetails[]
  TnCAcceptance    TnCAcceptance?
  onBoarding       Onboarding     @relation("UserOnboarding", fields: [onBoardingId], references: [id])
  order            Order          @relation("paymentOrder", fields: [orderId], references: [id])
  joinedBy         User?          @relation("UserDirectJoin", fields: [parentReferralId], references: [vrKpId])
  parentB          User?          @relation("B LEVEL",fields: [parentBId],references: [id])
  parentC          User?          @relation("C LEVEL",fields: [parentCId],references: [id])

  childB           User[]         @relation("B LEVEL")
  childC           User[]         @relation("C LEVEL")
  directJoin       User[]         @relation("UserDirectJoin")
  directJoinOnBoarding       Onboarding[]         @relation("parentreferral")


  UserPayments     UserPayments[] @relation("payment-user")
  UserPayouts      UserPayout[]

  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([id])
  @@index([vrKpId])
  @@index([phone])
}

enum UserPaymentsType {
  LEVEL1
  LEVEL2
  LEVEL3
  L1BAR
  L2BAR
  L3BAR
}

model UserPayments{
  id                 String        @id @default(uuid())
  userId             String

  type               UserPaymentsType
  amount             Decimal

  status             PaymentStatus @default(INITIATED)

  paymentDetails     Json?

  user               User           @relation("payment-user",fields: [userId],references: [id])

  paymentDate        DateTime?

  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  @@index([userId, status, type])
  @@index([userId])
  @@index([status])
  @@index([type])
}

model Onboarding {
  id                 String         @id @default(uuid())
  fullname           String
  relationType       RelationType
  relationName       String
  dob                DateTime
  address            Address?       @relation("OnboardingAddress")
  phone              String         @unique
  phoneVerified      Boolean
  email              String
  emailVerified      Boolean
  aadhaar            String
  aadhaarVerified    Boolean
  gender             GenderType     @default(None)
  userPhoto          String
  nominieeName       String
  nominieeDob        DateTime
  relationship       String
  
  referralId         String?        @unique
  
  parentreferralId   String?
  parentrederral     User?    @relation("parentreferral",fields: [parentreferralId],references: [vrKpId])

  onBoardingFinished Boolean        @default(false)
  orders             Order[]        @relation("OnBoardingPaymentOrder")
  TnCAcceptance      TnCAcceptance?
  user               User?          @relation("UserOnboarding")
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt


  @@index([id, phone])
  @@index([id])
  @@index([phone])
}

model Address {
  id            String   @id @default(uuid())
  addressLine   String
  addressLine2  String?
  StateId       String
  State         States  @relation(fields: [StateId],references: [id])
  pincode       String


  onboardingId String?  @unique
  onboarding   Onboarding? @relation("OnboardingAddress", fields: [onboardingId], references: [id])

  userId       String?  @unique
  user         User?    @relation("UserAddress", fields: [userId], references: [id])

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model States {
  id            String   @id @default(uuid())
  name          String
  code          String?
  isActive      Boolean
  avaliableLands  LandParcel[]
  LandAllocation  LandAllocation[]
  addresses     Address[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

enum AccountType {
  SAVINGS
  CURRENT
}

model BankDetails {
  id            String   @id @default(uuid())
  bankName      String
  accountNumberEnc String
  ifscCode      String
  branch        String
  userId        String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  User          User     @relation(fields: [userId], references: [id], onDelete: Cascade)


  accountHolderName      String
  accountType            AccountType  @default(SAVINGS)
  upiId                  String?
  isPrimary              Boolean   @default(false)
  

  @@index([userId])
  @@unique([userId, accountNumberEnc])
}

model GmailVerificationCode {
  id        String   @id @default(uuid())
  email     String   @unique
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model PhoneVerificationCode {
  id        String   @id @default(uuid())
  phone     String   @unique
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Order {
  id                  String      @id @default(cuid())
  orderId    String      @unique
  status              OrderStatus @default(PENDING)
  totalAmount         Decimal     @default(4999)
  currency            String      @default("INR")
  notes               String?
  onBoardingId        String
  phone               String?
  email               String?
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  onBoarding          Onboarding  @relation("OnBoardingPaymentOrder", fields: [onBoardingId], references: [id])
  payments            Payment[]
  user                User?       @relation("paymentOrder")

  @@index([orderId])
}

model Payment {
  id               String        @id @default(cuid())
  paymentSessionId String        @unique
  status           PaymentStatus @default(INITIATED)
  amount           Decimal
  currency         String        @default("INR")
  paymentMethod    String?
  gatewayResponse  Json?
  errorMessage     String?
  processedAt      DateTime?
  orderId          String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  paymentOrderId   String        @unique
  order            Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model TnCVersion {
  id            String          @id @default(uuid())
  version       String
  content       String
  active        Boolean         @default(false)
  createdAt     DateTime        @default(now())
  TnCAcceptance TnCAcceptance[]
}

model TnCAcceptance {
  id           String     @id @default(uuid())
  userId       String?    @unique
  onboardingId String     @unique
  tncVersionId String
  acceptedAt   DateTime   @default(now())
  createdAt    DateTime   @default(now())
  onboarding   Onboarding @relation(fields: [onboardingId], references: [id])
  tncVersion   TnCVersion @relation(fields: [tncVersionId], references: [id])
  user         User?      @relation(fields: [userId], references: [id])
}

enum GenderType {
  Male
  Female
  Others
  None
}

enum RelationType {
  So @map("S/o")
  Do @map("D/o")
  Wo @map("W/o")
}

enum TCOptions {
  ACCEPTED
  REJECTED
}

enum OrderStatus {
  PENDING
  PROCESSING
  PAID
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentStatus {
  INITIATED
  PENDING
  SUCCESS
  FAILED
  FLAGGED
}

enum SmsStatus {
  QUEUED
  SUBMITTED
  DELIVERED
  FAILED
}

model SmsMessage {
  id               String    @id @default(cuid())
  mobile           String    @db.VarChar(15)
  templateId       String
  text             String
  campId           String?   @unique
  status           SmsStatus @default(QUEUED)
  attempts         Int       @default(0)
  lastError        String?
  idempotencyKey   String?
  processingToken  String?
  processingExpiresAt    DateTime?
  fakeTrigger      String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([mobile, status])
  @@index([idempotencyKey])
}

enum PayoutStatus {
  REQUESTED     // created, awaiting review
  APPROVED      // approved to be paid (included in an APPROVED/POSTED batch)
  PAID          // admin marked as paid (manual bank)
  FAILED        // attempted but failed; may retry
  CANCELLED     // withdrawn or invalid
}

enum BatchStatus {
  DRAFT
  READY
  APPROVED
  POSTED
  DISBURSED     // all payouts marked PAID or FAILED
  RECONCILED    // admin verified with bank statements
  CANCELLED
}

enum Currency {
  INR
}

model UserPayoutType {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  defaultAmountPaise BigInt?    // optional default
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  payouts     UserPayout[]
}

model PayoutBatch {
  id            String     @id @default(cuid())
  name          String
  status        BatchStatus @default(DRAFT)
  createdById   String
  createdBy     Admin      @relation(fields: [createdById], references: [id])
  approvedById  String?
  approvedBy    Admin?     @relation("PayoutBatchApprovedBy", fields: [approvedById], references: [id])
  currency      Currency    @default(INR)
  totalAmountPaise BigInt   @default(0)
  scheduledAt   DateTime?
  postedAt      DateTime?
  disbursedAt   DateTime?
  reconciledAt  DateTime?
  metadata      Json?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  payouts       UserPayout[]
  payoutAttachments PayoutAttachment[]
  @@index([status, createdAt])
}

model UserPayout {
  id             String       @id @default(uuid())
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  typeId         String
  type           UserPayoutType @relation(fields: [typeId], references: [id])

  requestedAmountPaise BigInt   // what the system/user proposed
  approvedAmountPaise  BigInt?  // final approved amount (can differ)
  currency       Currency  @default(INR)

  status         PayoutStatus @default(REQUESTED)

  // approval chain (optional for MVP single-approver)
  requestedById  String?
  requestedBy    Admin?      @relation("PayoutRequestedBy", fields: [requestedById], references: [id])

  approvedById   String?
  approvedBy     Admin?      @relation("PayoutApprovedBy", fields: [approvedById], references: [id])
  approvedAt     DateTime?

  // payment proof & reconciliation
  paymentDate    DateTime?
  bankReference  String?     // UTR or note; optional but useful
  paymentDetails Json?       // any extra JSON (bank name, account tail, etc.)

  // batch linkage (nullable so a payout can exist before batching)
  batchId        String?
  batch          PayoutBatch? @relation(fields: [batchId], references: [id])

  // safety
  idempotencyKey String? @unique
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([userId, status, createdAt])
  @@index([batchId, status])
}

model PayoutAttachment {
  id          String   @id @default(cuid())
  payoutBatchId    String
  payout      PayoutBatch @relation(fields: [payoutBatchId], references: [id], onDelete: Cascade)
  kind        String   // "BANK_PROOF", "NOTE", etc.
  fileUrl     String?  // if you store files in R2/Cloudinary
  note        String?
  createdById String
  createdBy   Admin    @relation(fields: [createdById], references: [id])
  createdAt   DateTime @default(now())

  @@index([payoutBatchId, kind])
}

model AdminPermission {
  id        String   @id @default(uuid())
  code      String   @unique // e.g. "payout.batch.approve"
  label     String

  ROLE_PERMISSIONS RolePermission[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RolePermission {
  id           String        @id @default(uuid())
  role         AdminRole
  permission   AdminPermission @relation(fields: [permissionId], references: [id])
  permissionId String
  createdAt    DateTime      @default(now())

  @@unique([role, permissionId])
}


// model AdminSession {
//   id            String   @id @default(cuid())
//   adminId       String
//   admin         Admin    @relation(fields: [adminId], references: [id])
//   userAgent     String?
//   ip            String?
//   valid         Boolean  @default(true)
//   lastRotatedAt DateTime @default(now())
//   expiresAt     DateTime
//   createdAt     DateTime @default(now())

//   @@index([adminId])
// }

// model AdminApiKey {
//   id           String   @id @default(cuid())
//   adminId      String
//   admin        Admin    @relation(fields: [adminId], references: [id])
//   name         String
//   hashedKey    String   // store hash only
//   scopes       String[] // list of permission codes or scope strings
//   valid        Boolean  @default(true)
//   createdAt    DateTime @default(now())
//   lastUsedAt   DateTime?
// }

model AdminAuditLog {
  id          String   @id @default(cuid())
  actorId     String?  // null if system
  actor       Admin?   @relation("ActorAdminAuditLogs", fields: [actorId], references: [id])
  targetType  String   // "User","Admin","PayoutBatch","Rule"
  targetId    String?
  action      String   // "CREATE","UPDATE","DELETE","APPROVE","LOGIN","SHADOW_LOGIN"
  reason      String?
  metadata    Json?
  ip          String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([targetType, targetId])
  @@index([action, createdAt])
}


// model WebAuthnCredential {
//   id           String  @id @default(cuid())
//   adminId      String
//   admin        Admin   @relation(fields: [adminId], references: [id])
//   name         String
//   publicKey    Bytes
//   credentialId Bytes   @unique
//   counter      Int     @default(0)
//   createdAt    DateTime @default(now())
// }



model VRKP_Card {
  id            String   @id @default(uuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  cardIssuedAt  DateTime @default(now())
  cardNumber    String   @unique
  cardUrl       String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}


// ---------- Enums ----------
enum LandUnitStatus {
  AVAILABLE   // selectable
  RESERVED    // temporarily locked while user is in checkout flow
  ALLOTTED    // permanently assigned to a user
  INACTIVE    // hidden/removed by admin (e.g., dispute, error)
}

enum AllocationStatus {
  PENDING     // created but not confirmed (optional step)
  CONFIRMED   // final, user owns this unit
  CANCELLED   // reversed by admin or user cancelled
}


model LandParcel {
  id             String        @id @default(uuid())
  stateId        String
  state          States         @relation(fields: [stateId], references: [id], onDelete: Restrict)

  title          String        // human-friendly label
  surveyNumber   String        // as given in records
  areaSqYards    Int           // total area in sq yards (should be even)
  // 2 sq yards = 1 unit. Units are materialized in LandParcelUnit.

  addressLine    String?       // optional descriptive location
  latitude       Decimal?      @db.Decimal(9,6)
  longitude      Decimal?      @db.Decimal(9,6)

  // Optional denormalized counters for fast filters (kept in sync at app level)
  unitsTotal     Int           // total 2-sq-yd units = areaSqYards / 2
  unitsAvailable Int           // quick filter; recompute on writes

  units          LandParcelUnit[]
  LandAllocation  LandAllocation[]

  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@unique([stateId, surveyNumber]) // a survey number is unique within a state
  @@index([stateId])
  @@index([surveyNumber])
  @@index([unitsAvailable])
}

model LandParcelUnit {
  id             String          @id @default(uuid())
  landParcelId   String
  landParcel     LandParcel      @relation(fields: [landParcelId], references: [id], onDelete: Cascade)

  unitNumber     Int             // 1..N within a parcel
  status         LandUnitStatus  @default(AVAILABLE)

  // Soft lock to avoid race conditions during selection/checkout.
  // Treat a unit as selectable only if:
  //   status = AVAILABLE AND (lockedUntil IS NULL OR lockedUntil < now())
  lockedUntil    DateTime?

  // Optional: traceability / admin notes
  note           String?

  // Reverse relation to allocation (if allotted)
  allocation     LandAllocation?

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@unique([landParcelId, unitNumber]) // each unit number unique within a parcel
  @@index([status])
  @@index([lockedUntil])
}

// ---------- Allocation ----------
model LandAllocation {
  id               String          @id @default(uuid())

  // The user who gets the 2-sq-yd unit
  userId           String
  user             User            @relation(fields: [userId], references: [id], onDelete: Restrict)

  // The specific 2-sq-yd unit allotted
  landParcelUnitId String          @unique
  unit             LandParcelUnit  @relation(fields: [landParcelUnitId], references: [id], onDelete: Restrict)

  // Administrative bookkeeping
  status           AllocationStatus @default(CONFIRMED)
  referenceNo      String           @unique // e.g., "ALLOC-2025-000123"
  allocatedAt      DateTime         @default(now())
  allocatedById    String?          // Admin who confirmed
  allocatedBy      Admin?           @relation(fields: [allocatedById], references: [id], onDelete: SetNull)

  // Generated doc (small PDF) location
  docPdfUrl        String?

  // For quick filters
  stateId          String
  state            States            @relation(fields: [stateId], references: [id], onDelete: Restrict)

  landParcelId     String
  landParcel       LandParcel       @relation(fields: [landParcelId], references: [id], onDelete: Restrict)

  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  @@index([userId])
  @@index([stateId])
  @@index([landParcelId])
  @@index([allocatedAt])
}


enum BenefitType {
  INSURANCE
}


model Benefit {
  id          String   @id @default(uuid())
  title       String
  BenefitType  BenefitType @default(INSURANCE)
  content     String?
  isActive    Boolean  @default(true)

  userId     String // users who have accepted this version
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  details    Json?  // optional JSON for extra info

  docUrls    String[] // optional URL to related documents 

  createdById String?
  createdBy   Admin?  @relation(fields: [createdById], references: [id], onDelete: SetNull)

  issuedAt    DateTime? @default(now())
  validUntil  DateTime?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}